# -*- coding: utf-8 -*-
"""NumericalAnalysisAt_ItsLittle_Use.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vzcOUrAcPzj_UUdrNhop2lqTyH1Vvn0N
"""

"Given the function f(x)= x**3-7*x+2 in the interval [0,1] with starting point x0=0. Finfthe soulution of f(x) with accuracy of 0.01."

#Using BISECTION METHOD
"Import the libaries I am going to use"
import numpy as np
from math import *

"Defining the function"
def fnt(x):
  return x**3 - 7*x + 2
"The error method"
def BISECTION_ERROR(f, a, b, error):
  "Check if a and b are solutions themselves"
  if f(a) == 0:
    return a
  elif f(b) == 0:
    return b
  else:
    
    
    #If a and b are solutions, calculate the midpoint"
    while abs(a - b) > error:
      
      c = (a + b)/2.
      #Check if there is a solution between the midpoint and the start of the interval"
      if f(a)*f(c) < 0:
        return BISECTION_ERROR(f, a, c, error)
         
      else:
      #Check if there is a solution between the midpoint and the end of the interval"
        return BISECTION_ERROR(f, c, b, error)
    return (a + b)/2.2

for i in range (10, 50, 10):
  print(BISECTION_ERROR(fnt, 0., 1., 0.01))

#Using LAGRANGE METHOD
"This method is similar to the Bisection method, except c is calculated differently"

def LAGRANGE_ERROR(f, a, b, error):
  "Check if a and b are solutions themselves"
  if f(a) == 0:
    return a
  elif f(b) == 0:
    return b
  else:
    
    
    #If a and b are solutions, calculate the midpoint"
    while abs(a - b) > error:
      
      c = ((a*f(b)) - (b*f(a)))/ f(b) - f(a)
      #Check if there is a solution between the midpoint and the start of the interval"
      if f(a)*f(c) < 0:
        return BISECTION_ERROR(f, a, c, error)
         
      else:
      #Check if there is a solution between the midpoint and the end of the interval"
        return BISECTION_ERROR(f, c, b, error)
    return (a + b)/2.2

for i in range (10, 50, 10):
  print(LAGRANGE_ERROR(fnt, 0., 1., 0.01), BISECTION_ERROR(fnt, 0., 1., 0.01))

#Using FIXED_POINT METHOD

"Defining the function g(x)"
def g(x):
  return  x - 6*x + 2

"The error method"
def FIXEDP_ERROR(g, a, error):
  "With the fixed method, we use the previous value to get the next value before we can compare the absolute difference of two x values with the error"
  "Here is how the second value can be found"
  x0 = a
  print("here")
  x1 = g(x0)
  print("ENDs")
  while abs(x0 - x1) > error:
    "Because I need to modify x1 and x0 each time I enter the look, before modifying x1 I copy it to x0 so that I can use it in the comparison in the while"
    x0 = x1
    print(x1)
    x1 = g(x1)
  return x1



#Something is wrong, how does one fix this problem??
for i in range (10, 50, 10):
  print(FIXEDP_ERROR(g, 2., 0.01))

#Using NEWTONRAPHSON METHOD

"""Function to use"""
def f1(x):
  return x**3 - x -3

"""""""Derivative of f1"""""""
def ff1(x):
  return 3*x**2 - 1

""""""""""The error method"""""""""""""""
def NEWTON_P_ERROR(f, ff,  x0, n):
  """""Calculate the next value using the previous value"""""
  x1 = x0 -f(x0)/ff(x0)
  for i in range (n):
    """Update x0 before modifying x1"""
    x0 = x1
    x1 = x1 - (f1(x0)/ff1(x0))
  return x1



for i in range(10, 50, 10):
  
  print (round(NEWTON_P_ERROR(f1, ff1, 0, 5), 3), round(NEWTON_P_ERROR(f1, ff1, 1, 5),3))

#Using the SECANT METHOD
""" Define the function """
def f2(x):
  return x**3 - x - 3

"""" The iteration method """
def SECANT_ITE(f, x0, x1, n):
  
  for i in range (n):
    x2 = x1 - f(x1)*(x1 - x0/ f(x1) - f(x0))
    x0 = x1
    x1 = x2
  return x2

print(SECANT_ITE(f2, 0, 1, 5))

#Plotting using pylab
import matplotlib.pyplot as plt 

x = np.linspace(0, 50, 5)
y = fnt(x)

plt.plot(x, y, label = 'Graph', color = "Purple")
plt.xlabel("x-axis")
plt.ylabel("y-axis")
plt.plot(y=0)

plt.legend()
plt.show()